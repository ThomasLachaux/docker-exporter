import { Request } from 'express';
import split from 'split';
import http from 'http';
import morganMiddleware from 'morgan';
import { createLogger, format, transports } from 'winston';
import moment from 'moment';
import env from './env';

const getIp = (request: Request | http.IncomingMessage): string =>
  (request.headers['x-forwarded-for'] as string) || request.socket.remoteAddress;

// Create console Transport
const { combine, colorize, printf, errors } = format;

const formats = [
  errors({ stack: true }),
  printf(
    ({ level, message, stack }) => `${moment().format('HH:mm:ss')} ${level}: ${message} ${stack ? `\n${stack}` : ''}`,
  ),
];

if (env.development) {
  formats.unshift(colorize());
}

const logger = createLogger({
  format: combine(...formats),
  transports: [new transports.Console()],
  level: 'silly',
});

export default logger;

/**
 * Creates a morgan middleware with ip and username varibles
 * The logging is more verbose when in production
 */
export const morgan = () => {
  // Map morgan with winston
  // Split allows to remove the additional newline generated by the stream
  const logStream = split().on('data', (message: string) => logger.http(message));

  morganMiddleware.token('ip', getIp);

  const productionFormat = ':ip :method :url :status :res[content-length] - :response-time ms';
  const developmentFormat = ':method :url :status :response-time ms - :res[content-length]';

  // We use process.env.NODE_ENV because this file is imported by env.js
  return morganMiddleware(process.env.NODE_ENV === 'production' ? productionFormat : developmentFormat, {
    stream: logStream,
  });
};
