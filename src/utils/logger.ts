import { Request } from 'express';
import { ConsoleTransportInstance } from 'winston/lib/winston/transports';
import split from 'split';
import http from 'http';
import morganMiddleware from 'morgan';
import { createLogger, format, transports } from 'winston';
import moment from 'moment';

const getIp = (request: Request | http.IncomingMessage): string =>
  (request.headers['x-forwarded-for'] as string) || request.connection.remoteAddress || request.socket.remoteAddress;

// Create console Transport
const { combine, colorize, printf, errors } = format;
const consoleTransport = new transports.Console({
  format: combine(
    colorize(),
    errors({ stack: true }),
    printf(({ level, message }) => `${moment().format('HH:mm:ss')} ${level}: ${message}`),
  ),
  level: 'silly',
});

const loggingTransports: Array<ConsoleTransportInstance> = [consoleTransport];

// Create the production/development logger
const logger = createLogger({
  transports: loggingTransports,
});

export default logger;

/**
 * Creates a morgan middleware with ip and username varibles
 * The logging is more verbose when in production
 */
export const morgan = () => {
  // Map morgan with winston
  // Split allows to remove the additional newline generated by the stream
  const logStream = split().on('data', (message: string) => logger.http(message));

  morganMiddleware.token('ip', getIp);

  const productionFormat = ':ip :method :url :status :res[content-length] - :response-time ms';
  const developmentFormat = ':method :url :status :response-time ms - :res[content-length]';

  // We use process.env.NODE_ENV because this file is imported by env.js
  return morganMiddleware(process.env.NODE_ENV === 'production' ? productionFormat : developmentFormat, {
    stream: logStream,
  });
};
